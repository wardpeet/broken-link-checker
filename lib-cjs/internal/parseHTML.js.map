{"version":3,"file":"parseHTML.js","names":["_default2","_interopRequireDefault","require","_isStream","_isString","_parse","_parse5ParserStream","e","__esModule","default","ERROR_EVENT","FINISH_EVENT","OPTIONS","sourceCodeLocationInfo","treeAdapter","defaultTreeAdapter","createElement","args","result","attrMap","simplifyAttrs","attrs","Object","fromEntries","map","name","value","_default","input","Promise","resolve","reject","isStream","parser","ParserStream","once","document","setEncoding","pipe","isString","parse","TypeError","exports","module"],"sources":["../../lib/internal/parseHTML.js"],"sourcesContent":["import defaultTreeAdapter from \"parse5/lib/tree-adapters/default\";\nimport isStream from \"is-stream\";\nimport isString from \"is-string\";\nimport {parse} from \"parse5\";\nimport ParserStream from \"parse5-parser-stream\";\n\n\n\nconst ERROR_EVENT = \"error\";\nconst FINISH_EVENT = \"finish\";\n\n\n\nconst OPTIONS =\n{\n\tsourceCodeLocationInfo: true,\n\ttreeAdapter:\n\t{\n\t\t...defaultTreeAdapter,\n\n\t\tcreateElement: (...args) =>\n\t\t{\n\t\t\tconst result = defaultTreeAdapter.createElement(...args);\n\t\t\tresult.attrMap = simplifyAttrs(result.attrs);\n\t\t\treturn result;\n\t\t}\n\t}\n};\n\n\n\n/**\n * Convert a list of parse5 attributes into key-value pairs.\n * Note: spec-compliant HTML cannot have multiple attrs of the same name.\n * @param {Array} attrs\n * @returns {object}\n *\n * @todo https://github.com/tc39/proposal-pipeline-operator\n */\nconst simplifyAttrs = attrs => Object.fromEntries(attrs.map(({name, value}) => [name, value]));\n\n\n\n/**\n * Parse an HTML stream/string and return a tree.\n * @param {Stream|string} input\n * @throws {TypeError} non-Stream or non-string\n * @returns {Promise<object>}\n */\nexport default input => new Promise((resolve, reject) =>\n{\n\tif (isStream(input))\n\t{\n\t\tconst parser = new ParserStream(OPTIONS)\n\t\t.once(ERROR_EVENT, reject)  // @todo test this\n\t\t.once(FINISH_EVENT, () => resolve(parser.document));\n\n\t\tinput\n\t\t\t.setEncoding(\"utf8\")\n\t\t\t.pipe(parser);\n\t}\n\telse if (isString(input))\n\t{\n\t\tresolve( parse(input, OPTIONS) );\n\t}\n\telse\n\t{\n\t\treject( new TypeError(\"Invalid input\") );\n\t}\n});\n"],"mappings":";;;;;;AAAA,IAAAA,SAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,SAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,SAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AACA,IAAAI,mBAAA,GAAAL,sBAAA,CAAAC,OAAA;AAAgD,SAAAD,uBAAAM,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAIhD,MAAMG,WAAW,GAAG,OAAO;AAC3B,MAAMC,YAAY,GAAG,QAAQ;AAI7B,MAAMC,OAAO,GACb;EACCC,sBAAsB,EAAE,IAAI;EAC5BC,WAAW,EACX;IACC,GAAGC,iBAAkB;IAErBC,aAAa,EAAEA,CAAC,GAAGC,IAAI,KACvB;MACC,MAAMC,MAAM,GAAGH,iBAAkB,CAACC,aAAa,CAAC,GAAGC,IAAI,CAAC;MACxDC,MAAM,CAACC,OAAO,GAAGC,aAAa,CAACF,MAAM,CAACG,KAAK,CAAC;MAC5C,OAAOH,MAAM;IACd;EACD;AACD,CAAC;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,aAAa,GAAGC,KAAK,IAAIC,MAAM,CAACC,WAAW,CAACF,KAAK,CAACG,GAAG,CAAC,CAAC;EAACC,IAAI;EAAEC;AAAK,CAAC,KAAK,CAACD,IAAI,EAAEC,KAAK,CAAC,CAAC,CAAC;;AAI9F;AACA;AACA;AACA;AACA;AACA;AALA,IAAAC,QAAA,GAMeC,KAAK,IAAI,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KACpD;EACC,IAAI,IAAAC,iBAAQ,EAACJ,KAAK,CAAC,EACnB;IACC,MAAMK,MAAM,GAAG,IAAIC,2BAAY,CAACtB,OAAO,CAAC,CACvCuB,IAAI,CAACzB,WAAW,EAAEqB,MAAM,CAAC,CAAE;IAAA,CAC3BI,IAAI,CAACxB,YAAY,EAAE,MAAMmB,OAAO,CAACG,MAAM,CAACG,QAAQ,CAAC,CAAC;IAEnDR,KAAK,CACHS,WAAW,CAAC,MAAM,CAAC,CACnBC,IAAI,CAACL,MAAM,CAAC;EACf,CAAC,MACI,IAAI,IAAAM,iBAAQ,EAACX,KAAK,CAAC,EACxB;IACCE,OAAO,CAAE,IAAAU,YAAK,EAACZ,KAAK,EAAEhB,OAAO,CAAE,CAAC;EACjC,CAAC,MAED;IACCmB,MAAM,CAAE,IAAIU,SAAS,CAAC,eAAe,CAAE,CAAC;EACzC;AACD,CAAC,CAAC;AAAAC,OAAA,CAAAjC,OAAA,GAAAkB,QAAA;AAAAgB,MAAA,CAAAD,OAAA,GAAAA,OAAA,CAAAjC,OAAA","ignoreList":[]}